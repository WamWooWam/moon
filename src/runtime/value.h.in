/*
 * value.h: Generated code for the type system.
 *
 * Contact:
 *   Moonlight List (moonlight-list@lists.ximian.com)
 *
 * Copyright 2007 Novell, Inc. (http://www.novell.com)
 *
 * See the LICENSE file included with the distribution for details.
 * 
 */

#ifndef MOON_VALUE_H
#define MOON_VALUE_H

#include <glib.h>

#include "type.h"
#include "enums.h"

namespace Moonlight {

/* 
 * ugly file containing the catchall value type we use.
 */

struct FontFamily;
struct FontSource;
struct FontResource;
struct FontWeight;
struct FontStyle;
struct FontStretch;
struct PropertyPath;
struct Color;
struct Duration;
struct KeyTime;
struct Point;
struct Rect;
struct Size;
struct Uri;
struct RepeatBehavior;
struct GridLength;
struct Thickness;
struct CornerRadius;
struct ManagedTypeInfo;
class AudioFormat;
class VideoFormat;

struct Value;

class Type;
class DependencyProperty;
class Surface;
class AnimationStorage;
class Playlist;
class PlaylistEntry;

/*DO_FWD_DECLS*/

#if SANITY || DEBUG
#define checked_get_enum() g_return_val_if_fail (Types::IsSubclassOrSuperclassOf (types, GetKind(), Type::ENUM), -1); return u.i64;
#define checked_get_datetime() g_return_val_if_fail (Types::IsSubclassOrSuperclassOf (types, GetKind(), Type::DATETIME), -1); return u.i64;
#define checked_get_exact(kind, errval, mem)  g_return_val_if_fail (GetKind() == (kind) && !GetIsManaged (), errval); return mem;
#define checked_get_subclass(kind, castas) \
	if (u.dependency_object == NULL || GetKind() == (kind))	\
		return (castas*)u.dependency_object;	\
	g_return_val_if_fail (!GetIsManaged (), NULL); \
	g_return_val_if_fail (Types::IsSubclassOrSuperclassOf (types, GetKind(), kind), NULL); \
	return (castas*)u.dependency_object;
#else
#define checked_get_enum() return u.i64;
#define checked_get_datetime() return u.i32;
#define checked_get_exact(kind, errval, mem) return mem;
#define checked_get_subclass(kind, castas) return (castas*)u.dependency_object;
#endif

#define NullMask      ((guint32)1 << 31)
#define GCHandleMask  ((guint32)1 << 30)
#define DoesNotNeedUnrefMask ((guint32)1 << 29)

#define FlagMask (NullMask | GCHandleMask | DoesNotNeedUnrefMask)
#define KindMask ~FlagMask


struct MOON_API Value {
public:
	void Init ();
	void Strengthen (Deployment *deployment);
	void Weaken (Deployment *deployment);
	bool HoldManagedRef (Deployment *deployment);
	
	Value ();
	Value (const Value& v);
	explicit Value (Type::Kind k);
	explicit Value (bool z);
	explicit Value (double d);
	explicit Value (gint32 i);
	explicit Value (guint32 i);
	Value (gunichar c, Type::Kind as); // for use with char values.
	Value (gint32 i, Type::Kind as); // Use for enums.
	Value (gint64 i, Type::Kind as); // Use for TimeSpan and int64 values.
	Value (Color c);
	Value (EventObject *obj);
	Value (FontFamily family);
	Value (const FontFamily *family);
	Value (FontSource source);
	Value (FontWeight weight);
	Value (FontStyle style);
	Value (FontStretch stretch);
	Value (FontResource source);
	Value (const PropertyPath *propertypath);
	Value (Point pt);
	Value (Rect rect);
	Value (Size size);
	Value (const Uri *uri);
	Value (RepeatBehavior repeat);
	Value (Duration duration);
	Value (KeyTime keytime);
	Value (GridLength grid_length);
	Value (Thickness thickness);
	Value (CornerRadius radius);
	Value (VideoFormat *format);
	Value (AudioFormat *format);
	Value (VideoFormat format);
	Value (AudioFormat format);
	Value (GlyphTypeface *typeface);
	Value (ManagedTypeInfo *type_info);
	Value (const char *s, Type::Kind kind, bool take = false);
	Value (Type::Kind, void *npobj);

	~Value ();

	// Use these to create Values with dependency objects with
	// a reference count of 1 (giving the ownership of the object
	// to Value).
	// Useful in cases like this:
	//   SetValue (SomeProperty, new DependencyObject ())
	// in which case we have to unref the newly created object.
	static Value* CreateUnrefPtr (EventObject* dob);
	static Value  CreateUnref (EventObject* dob);
	static Value* CreateUnrefPtr (Uri *uri);

	// essentially the same as the copy constructor, except it
	// does a deep copy of DependencyObjects.
	static Value* Clone (Value *v, Types *types = NULL);

	bool GetIsManaged () const { return (kind & GCHandleMask) == GCHandleMask; }

	static bool IsNull (const Value *value) { return value == NULL ? true : value->GetIsNull (); }
	bool GetIsNull () const { return (kind & NullMask) == NullMask; }
	void SetIsNull (bool isNull);

	bool GetNeedUnref () const { return (kind & DoesNotNeedUnrefMask) == 0; }
	void SetNeedUnref (bool needUnref);

	static bool AreEqual (const Value *v1, const Value *v2);

	bool operator!= (const Value &v) const;
	bool operator== (const Value &v) const;

	Value& operator= (const Value& other);
	
	bool		Is (Deployment *deployment, Type::Kind type) const { return Type::IsAssignableFrom (deployment, type, GetKind()); }
	bool		IsEventObject (Deployment *deployment) const;
	bool		IsDependencyObject (Deployment *deployment) const;

	bool		AsBool () const	            { checked_get_exact (Type::BOOL, false, (bool)u.i32); }
	gunichar	AsChar () const             { checked_get_exact (Type::CHAR, 0, u.c); }
	double 		AsDouble () const           { checked_get_exact (Type::DOUBLE, 0.0, u.d); }
	gint64		AsEnum (Types *types = NULL) const { checked_get_enum (); }
	float 		AsFloat () const	    { checked_get_exact (Type::FLOAT, 0.0, u.f); }
	guint64		AsUInt64 () const	    { checked_get_exact (Type::UINT64, 0, u.ui64); }
	gint64		AsInt64 () const	    { checked_get_exact (Type::INT64, 0, u.i64); }
	TimeSpan	AsTimeSpan () const	    { checked_get_exact (Type::TIMESPAN, 0, (TimeSpan)u.i64); }
	guint32		AsUInt32 () const	    { checked_get_exact (Type::UINT32, 0, u.ui32); }
	gint32		AsInt32 () const	    { checked_get_exact (Type::INT32, 0, u.i32); }
	Color*		AsColor () const	    { checked_get_exact (Type::COLOR, NULL, u.color); }
	Point*		AsPoint () const	    { checked_get_exact (Type::POINT, NULL, u.point); }
	const Uri*	AsUri () const	            { checked_get_exact (Type::URI, NULL, u.uri); }
	Rect*		AsRect () const	            { checked_get_exact (Type::RECT, NULL, u.rect); }
	Size*		AsSize () const	            { checked_get_exact (Type::SIZE, NULL, u.size); }
	FontFamily*	AsFontFamily ()	const       { checked_get_exact (Type::FONTFAMILY, NULL, u.fontfamily); }
	FontWeight*	AsFontWeight ()	const       { checked_get_exact (Type::FONTWEIGHT, NULL, u.fontweight); }
	FontStyle*	AsFontStyle () const	    { checked_get_exact (Type::FONTSTYLE, NULL, u.fontstyle); }
	FontStretch*	AsFontStretch() const       { checked_get_exact (Type::FONTSTRETCH, NULL, u.fontstretch); }
	FontSource*	AsFontSource ()	const       { checked_get_exact (Type::FONTSOURCE, NULL, u.fontsource); }
	FontResource*	AsFontResource() const      { checked_get_exact (Type::FONTRESOURCE, NULL, u.fontresource); }
	char*		AsString () const	    { checked_get_exact (Type::STRING, NULL, u.s); }
	char*		AsXmlLanguage () const	    { checked_get_exact (Type::XMLLANGUAGE, NULL, u.s); }
	DependencyProperty* AsDependencyProperty () const { checked_get_exact (Type::DEPENDENCYPROPERTY, NULL, u.dp); }
	gint64		AsDateTime (Types *types = NULL) const { checked_get_datetime (); }
	
	GCHandle	AsGCHandle () const;
	void *		AsManagedObject () const    { g_return_val_if_fail (GetIsManaged (), NULL); return u.managed_object; }
	void *		AsNPObj () const            { checked_get_exact (Type::NPOBJ, NULL, u.npobj); }
	
	RepeatBehavior*	AsRepeatBehavior () const   { checked_get_exact (Type::REPEATBEHAVIOR, NULL, u.repeat); }
	Duration*	AsDuration () const	    { checked_get_exact (Type::DURATION, NULL, u.duration); }
	KeyTime*	AsKeyTime () const	    { checked_get_exact (Type::KEYTIME, NULL, u.keytime); }
	GridLength*     AsGridLength () const       { checked_get_exact (Type::GRIDLENGTH, NULL, u.grid_length); }
	Thickness*      AsThickness () const        { checked_get_exact (Type::THICKNESS, NULL, u.thickness); }
	CornerRadius*   AsCornerRadius () const     { checked_get_exact (Type::CORNERRADIUS, NULL, u.corner); }
	/* nullable primitives (all but bool) */
	double*		AsNullableDouble ()         { checked_get_exact (Type::DOUBLE, NULL, &u.d); }
	guint64*	AsNullableUint64 ()         { checked_get_exact (Type::UINT64, NULL, &u.ui64); }
	gint64* 	AsNullableInt64 ()          { checked_get_exact (Type::INT64, NULL, &u.i64); }
	gint32* 	AsNullableInt32 ()          { checked_get_exact (Type::INT32, NULL, &u.i32); }
	
/*DO_AS*/
	
	char *ToString () const;
	
  	Type::Kind GetKind () const { return (Type::Kind)(kind & KindMask); }
	
	/* @GeneratePInvoke */
	static void FreeValue (Value *value);
	/* @GeneratePInvoke */
	static void FreeValue2 (/* @MarshalAs=IntPtr */ Value *value);


	/* @GeneratePInvoke */
	static void DeleteValue (Value *value);
	/* @GeneratePInvoke */
	static void DeleteValue2 (/* @MarshalAs=IntPtr */ Value *value);

	/* The implementation for this method is in xaml.cpp */
	/* Managed code must call value_free_value on the result */
	/* @GeneratePInvoke */
	static bool FromStrWithTypename (const char *type_name, const char *prop_name, const char *str, /* @MarshalAs=IntPtr,IsOut */ Value **v);

	/* The implementation for this method is in xaml.cpp */
	/* Managed code must call value_free_value on the result */
	/* @GeneratePInvoke */
	static bool FromStr (Type::Kind type, const char *prop_name, const char *str, /* @MarshalAs=IntPtr,IsOut */ Value **v);

  private:
	gint32 kind;

	GCHandle boxed_valuetype;

	union {
		double d;
		float f;
		guint64 ui64;
		gint64 i64;
		guint32 ui32;
		gint32 i32;
		gunichar c;
		char *s;
		EventObject *dependency_object;
		Color *color;
		DependencyProperty *dp;
		Point *point;
		Uri *uri;
		Rect *rect;
		Size *size;
		FontFamily *fontfamily;
		FontSource *fontsource;
		FontWeight *fontweight;
		FontStretch *fontstretch;
		FontStyle *fontstyle;
		FontResource *fontresource;
		PropertyPath *propertypath;
		RepeatBehavior *repeat;
		Duration *duration;
		KeyTime *keytime;
		GridLength *grid_length;
		Thickness *thickness;
		CornerRadius *corner;
		AudioFormat *audioformat;
		VideoFormat *videoformat;
		GlyphTypeface *typeface;
		ManagedTypeInfo *type_info;
		void *managed_object; // This should be a GCHandle, but g++ says that types with ctors/copy assignment operators can't be used in unions
		void *npobj;
	} u;

  	void SetKind (Type::Kind kind) { this->kind = (this->kind & FlagMask) | (kind & KindMask); }

	// You don't want to be using this ctor.  it's here to help
	// c++ recognize bad unspecified pointer args to Value ctors
	// (it normally converts them to bool, which we handle, so you
	// never see the error of your ways).  So do the world a
	// favor, and don't expose this ctor. :)
	Value (void *v) { }
	// You don't want to be using this ctor either.
	// Use the Value (gint64, Type::Kind) ctor
	// (Both for TimeSpan and int64_t)
	// This one is bad because it get used by either int64_t
	// and TimeSpan, and the constructor doesn't know which 
	// of the two types it is.
	explicit Value (gint64 i) {};
	// This could be a Type::XMLLANGUAGE or a Type::STRING so
	// use the (const char *s, Type::kind) ctor
	explicit Value (const char *s) {};
	void Copy (const Value& other);
	char *GetName ();

	void FreeValueInternal ();
};

};
#endif /* MOON_VALUE_H */
